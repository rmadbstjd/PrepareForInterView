Virtual이란 말 그대로 가상이고,

Dom은 Document Object Model의 약자로서, 문서 객체 모델을 의미합니다.

문서 객체란 HTML, head, body와 같은 태그들을 Javascript가 이용할 수 있는 객체를 의미합니다.

**Virtual Dom이 등장한 이유**

인터랙티브한 웹이 많아질수록 DOM 조작은 빈번하게 일어났습니다.

DOM 조작이 발생할 때 마다 렌더링이되고, 렌더링이 반복될수록 비효율적이게 됩니다.

이러한 문제를 해결하기 위해 Virtual Dom이 등장하였습니다.

**Virtual Dom이 등장한 또다른 이유**

리렌더링이 발생한다는 것은 특정 노드에 변화가 생겼다는 뜻입니다. 이러한 변화를 감지하기 위한 방법으로는 크게 Dirty Checking과 Observable 등이 있습니다.

Dirty Checking은 노드 트리를 재귀적으로 계속 순회하면서 어떤 노드에 변화가 생겼는지를 인식합니다. 그리고 변화된 노드만 리렌더링을 시켜주는 방법입니다. angular.js에서 사용하던 방식인데 이러한 방법을 사용하면 변화가 없을 때도 재귀적으로 노드 트리를 순회하여 불필요한 비용이 발생할 수 있습니다.

Observable은 변화가 생긴 노드가 관찰자에게 알림을 보내주는 방식입니다. 리액트의 경우에는 state에 변화가 생겼을 때 리액트에게 렌더링을 하라는 신호를 보내는 방식으로 이루어집니다.

이러한 방법을 사용하면 변화가 생기기 전 까지 비용이 발생하지 않습니다. 노드에 변화가 생겼다는 알림을 받으면 렌더링을 하는 방법은 효율적인 방법이라고 할 수 있습니다.

다만 Observable 방법에도 문제점이 있습니다. 변화에 대한 알림을 받으면 전체를 렌더링 시켜버린다는 점이었습니다. 전체를 렌더링하는 것은 엄청난 reflow,repiant 비용이 발생합니다. 이러한 문제를 해결하기 위해 Virtual DOM이 등장하였습니다.

**Virtual Dom이란**

 메모리상에 존재하는 하나의  Javascript 객체입니다. Virtual Dom을 사용하면, 리액트는 state에 변화가 생겼다는 알림을 받으면 Real Dom 전체를 리렌더링 하는 것이 아닌 Virtual Dom을 렌더링합니다. 

Real Dom 전체를 렌더링 하는 비용보다 객체를 새로 하나 만드는 비용이 더 저렴하기 때문에 

리액트는 Real Dom 전체를 렌더링 하지 않고, Virtual Dom이라는 메모리상의 객체를 새로 만드는 방식을 선택하였습니다. 

**Virtual Dom의 동작 원리**

1. Real Dom으로부터 Virtual DOM을 만듭니다.
2. 변화가 생기면 새로운 버전의 Virtual DOM을 만듭니다.
3. Old 버전의 Virtual Dom과 new 버전의 Virtual Dom을 비교합니다(diffing 알고리즘).
4. 비교 과정을 통해 발견한 차이점을 한 번에 Real Dom에 적용합니다.

**Reconcilation이란**

오래된 Virtual Dom과 최신의 Virtual Dom을 비교하여 차이점을 Real Dom에 적용하는 과정을 Reconcilation(재조정)이라고 합니다.

DOM은 Tree 형태이므로, 재조정은 두 Tree간의 차이를 비교하는 것이라고 볼 수 있습니다.

React 엘레먼트 트리를 만드는 render() 함수는 새로운 React 엘레먼트 트리를 반환하는데 필요한 알고리즘은 O(n^3)의 복잡도를 갖고 있기 때문에 리액트는 효과적인 휴리스틱 알고리즘을 구현하였습니다.

두 가지의 규칙이 있는데,

1. 서로 다른 타입의 두 엘레먼트는 서로 다른 트리를 만들어냅니다.
2. 개발자가 key prop을 통해 여러 렌더링 사이에서 어떤 자식 엘레먼트가 변경되지 않아야 할 지를 표시할 수 있습니다.

**비교 알고리즘(Diffing Algorithm)**

두 개의 트리를 비교할 때, 리액트는 두 엘리먼트의 루트 엘리먼트부터 비교합니다. 이후의 동작은 루트 요소의 타입에 따라 달라집니다. 비교하는 두 요소의 타입이 같을 때와 다를 때로 나눌 수 있습니다.

1. DOM 요소 타입이 다른 경우
    
    비교하는 두 요소의 타입이 다르면, 리액트는 이전 트리를 버리고 완전히 새로운 트리를 구축합니다. 
    
2. DOM 요소 타입이 같은 경우
    
    리액트는 두 요소의 속성을 확인하여, 동일한 속성은 유지하고 변경된 속성들만 갱신합니다. 이렇게 변경된 속성들을 갱신한 후, 해당 요소의 자식 노드들을 재귀적으로 처리합니다.
    
    자식에 대한 재귀 처리를 할 때, 기본적으로 동시에 두 리스트를 순회하면서 차이점이 있는지 확인한 후, 변경합니다.
    
    만약 자식 요소의 끝 부분에 추가되면 기존의 자식 요소들은 놔두고 마지막에 들어온 자식 요소만 추가해주면 되지만 만약 자식 요소가 첫 부분에 추가되면 성능이 매우 안좋아집니다.
    
    첫 번째 요소부터 일치하지 않으므로 리액트는 나머지 모든 요소들도 변경합니다.
    
    이러한 문제를 자식 요소에 key를 추가함으로써 해결할 수 있습니다.