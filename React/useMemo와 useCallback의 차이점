**useMemo와 useCallback을 사용하는 이유**

1. 부모 컴포넌트의 state가 변경 되면
2. 부모 컴포넌트가 리렌더링이 되고, 자식 컴포넌트에 넘겨주는 props가 새롭게 생성되고,
3. 해당 props가 참조 타입이라면 동일한 값이라도 동일한 참조 값이 아니기 때문에, 얕은 비교를 통해 새로운 값으로 판단하여 자식 컴포넌트가 리렌더링이 됩니다.

즉 참조 타입의 props는 상황에 따라 불필요한 리렌더링이 발생할 수 있기 때문에 이를 방지하기 위해 useCallback, useMemo등이 사용됩니다.

**메모제이션이란**

기존에 연산된 결과 값을 어딘가에 저장해두고 동일한 연산이 반복될 때, 값을 재활용하는 기법입니다.

이것을 적절하게 활용하면 반복된 연산을 피할수 있기 때문에 메모리를 조금 더 사용하더라도 성능을 최적화시킬 수 있습니다.

1. useCallback

   메모제이션된 함수를 반환합니다.

2. useMemo

   메모제이션된 값을 반환합니다.

   **중요한 점**

   우선 렌더링 단계는 크게 Render Phase와 Commit Phase로 나눌 수 있습니다.

   useMemo 혹은 useCallback을 사용하면 부모 컴포넌트가 리렌더링이 될 때 새로운 값이나 함수를 생성하는 것이 아닌 메모제이션된 값이나 함수를 사용합니다. 따라서 새롭게 값이나 함수를 생성하는 것이 아닌 메모제이션된 값이나 함수를 사용하기 때문에 자식 컴포넌트는 Render Phase의 재조정 과정에서 이전의 props와 새롭게 받은 props가 일치하여 Real Dom에게 변경된 부분을 업데이트하는 Commit Phase가 실행되지 않습니다. 따라서 Commit Phase는 막았지만 Render Phase는 막지 못하였습니다.

   **그렇다면 Render Phase는 어떻게 막을까요?**

   React.memo를 통해 막을 수 있습니다. React.memo는 전달받은 props와 이전 props와의 얕은 비교를 통해 같으면 컴포넌트의 리렌더링을 막아줌으로써 Render Phase와 Commit Phase를 모두 막아 해결하였습니다.
