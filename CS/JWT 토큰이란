우선 JWT 토큰의 등장 배경에 대해 먼저 설명드리겠습니다.

쿠키와 세션을 이용한 세션 기반 인증의 문제점을 개선하기 위해 등장하였습니다.

세션 기반 인증이란?

1. 유저가 id,pw 등 로그인에 필요한 정보를 서버에 보냅니다.
2. 서버는 id, pw를 통해 유호성 검사를 합니다. 검증이 완료되면 사용자에 대한 정보를 고유한 ID를 기준으로 서버 내 특정 공간에 저장합니다. 이 때  특정 공간이 세션 저장소이고, 고유 ID값으로 저장되는 정보를 세션이라고 합니다.
3. 서버는 응답 헤더에 세션 ID를 포함시켜 응답합니다.
4. 클라이언트는 응답 받은 세션 ID를 클라이언트 내부의 공간에 저장하는데 이때 내부의 공간이 쿠키입니다.
5. 사용자는 인증이 필요한 요청에 세션 ID가 담긴 쿠키를 요청 헤더에 담아 보내고, 서버는 세션 저장소에 세선 ID와 일치하는 세션 ID가 있는지 검증 후 응답합니다.

세션 기반 인증의 문제점

HTTP의 가장 큰 특징인 Stateless를 위배한다는 것입니다.

Stateless라면 서버는 클라이언트의 상태를 저장하지 않아야 하지만 세션 저장소라는 곳에 클라이언트의 정보를 저장하므로 Stateful하게 됩니다.

만약 서버를 스케일 아웃해야 한다면 1번 서버에 로그인한 유저가 2번 서버로 요청을 보낸다면 2번 서버에는 로그인 상태가 남아있지 않기 때문에 다시 로그인을 해야 하는 경우가 발생합니다.

세션 클러스터링(Session Clustering)을 통해  서버간 로그인 정보가 담긴 세션을 공유하는 방법이 있지만 세션 저장소에 데이터가 추가될 때 마다 모든 서버에 부담이 되므로 서버가 늘어날수록 이 방법은 적합하지 않습니다.

스티키 세션(Sticky Session)을 통해 스케일 아웃시, 유저가 A서버에 맨 처음 요청했다면 그 다음의 요청도 모두 A서버가 처리하는 방식을 통해 문제를 해결할 수는 있지만 이 방법도 단점이 존재합니다.

각 서버가 요청들을 균일하게 처리할 수 없다는 점, 특정 서버에 요청이 몰려도 로드 밸런싱을 할 수 없다는 점입니다.

결국 이러한 문제를 해결하기 위해 JWT가 등장하였습니다.

JWT(Json Web Token)은 토큰 기반 인증으로, 세션 기반 인증과 다르게 토큰을 이용하여 인증을 하는 방식입니다.

토큰 자체에 유저 정보를 담아서 HTTP 헤더로 전달합니다.

서버에서 상태 정보를 저장하는 세션 기반 인증과 다르게 토큰 기반 인증은 서버에서 상태 정보를 저장하지 않습니다. 토큰 자체가 유효한지 유효하지 않은지만 판별하면 되기 때문에 서버에 부하를 주지 않습니다. 물론 단점도 있습니다. Stateless한 토큰의 특성 때문에 토큰을 강제로 만료시킬수 없습니다. 토큰이 만약 탈취당했다면 토큰이 만료될때까지 해커가 서버에 요청할 수 있습니다.

따라서 토큰 기반 인증을 구현하려면 보안에 주의해야합니다.

이러한 보안에 대비하기 위해 Refresh Token이 등장하였습니다.

Access Token만으로는 해커가 요청하는지, 정상적인 유저가 요청하는지를 알 수 없기 때문입니다.

따라서 Access Token의 유효 기간을 짧게 설정하고 Refresh Token의 유효 기간을 길게 설정하여

대응할 수 있습니다.

Access Token은 로컬 스토리지 혹은 세션 스토리지에 저장하고, Refresh Token은 쿠키에 저장한 다음, HTTP Only, Secure Cookies를 활성화 합니다.

HTTP Only란?

클라이언트에서 자바스크립트로 쿠키를 조회할 수 있는데 해당 옵션을 활성화하면 브라우저에서 쿠키에 접근할 수 없으므로 XSS같은 공격에 안전하다.

Secure Cookies란?

HTTPS 프로토콜이 아닌 경우 쿠키를 전송하지 않도록 하는 것이다.

만약 Refresh Token이 탈취당한다면?

해커는 탈취한 Refresh Token으로 계속 Access Token을 발급해 서버에 계속 요청할 수 있습니다.

따라서 서버에서는 추가 검증 로직을 작성해야 합니다.

1. 정상적인 유저의 Access Token이 만료된 경우
    
    유저가 Access Token과 Refresh Token을 서버애 보내면 서버는 저장된 Access Token과 RefreshToken과 비교하여 일치하면 새로운 AccessToken을 발급합니다.
    
2. 공격자가 Refresh Token을 탈취한 경우
    
    공격자가 탈취한 Refresh Token으로 Access Token을 요청한면 Access Token 없이 Refresh Token만 보냈기 때문에 공격으로 간주하여 그 즉시 Accses Token과 Refresh Token을 폐기합니다.
    

만약 Refres Token과 Access Token이 모두 탈취되었다면?

방법이 없는 걸로 알고 있습니다…

Refresh Token을 사용하면 포기해야 하는 것들이 있습니다.

결국 Refresh Token을 서버의 한 곳에 저장을 해야 하기 때문에 더 이상 Stateless하지 않게 됩니다.

하지만 세션 인증 방식은 로그인할 때 마다 세션 저장소에 접근하지만

JWT는 Access Token이 만료되었을 때만 저장소에 접근하기 때문에 접근 횟수 자체는 훨씬 적다는 장점은 있습니다.