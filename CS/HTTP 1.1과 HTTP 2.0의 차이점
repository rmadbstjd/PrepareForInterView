HTTP 1.1은 기본적으로 Connection 당 하나의 요청을 할 수 있습니다.

그렇기 때문에 여러 개의 전송을 한 번에 보낼 수 없었고 하나의 요청에 대한 응답이 온 후에 다시 요청을 보낼 수 있습니다.

이러한 특징은 수많은 리소스들(html,css,javascript,image 등)을 처리하려면 요청할 리소스의 갯수에 비례해 지연시간이 길어집니다.

이를 해결하기 위해 HTTP Pipelining이 도입되었습니다.

TCP 안에 두 개 이상의 HTTP 요청을 담아 지연 시간을 줄이는 방법이지만 이는

HOL(Head of Line) Blocking이 발생합니다.

HOL Blocking이란  앞선 요청에 의해 뒤의 요청이 지연되는 것을 의미합니다.

예를 들어 한 번에 여러 개의 이미지를 요청했을 때

가장 앞에 요청한 이미지가 지연되면 그 뒤에 이미지들도 지연이 발생합니다.

TCP 안에 여러 개의 요청이 왔으므로 ‘완료된 응답부터 내보내면 되지 않나’라고 생각할 수 있지만

서버는 TCP에서 요청이 온 순서대로 응답을 해야 합니다.

또한 클라이언트와 서버간 무수히 많은 HTTP 요청이 발생할 것이고 헤더의 정보는 대부분 동일합니다. 하지만 HTTP 1.1에서는 이러한 헤더를 중복해서 보내며, 이는 불필요한 데이터를 주고 받는데 네트워크 자원이 소비되는 문제가 발생합니다.

따라서 HTTP 1.1을 개선하는 방향으로 HTTP 2.0이 등장하였습니다.

1. Multiple Streams
    
    HTTP Pipelining의 개선안으로 하나의 Connection에 병렬적으로 파일을 전송하여 Blocking 문제를 해결하였다.
    
2. Header Compression
    
    HTTP 1.1의 경우 중복되는 header도 똑같이 전송하느라 네트워크 자원이 낭비되었지만
    
    HTTP 2.0의 경우 중복되는 부분은 재전송하지 않고, 변경되는 값만 보냄으로써 Header의 크기를 경량화시켰습니다.