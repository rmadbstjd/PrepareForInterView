/*
자바스크립트는 완벽하게 같은 함수라도 어떤 객체에 의해 호출되느냐에 따라, this의 의미가 달라집니다.

자바스크립트에서 모든 함수는 this를 갖고 있습니다. 그리고 함수가 호출되면 상황에 따라 this가 가르키는 객체가 결정됩니다. 

이렇게 함수가 호출될 때 마다 this가 동적으로 결정되는데, 이를 바인딩이라고 합니다.

1. 전역 공간에서의 this는 전역 객체(window)를 값으로 갖습니다.
2. 메소드 호출 시 메소드 내부의 this는 해당 메소드를 호출한 객체를 값으로 갖습니다.
3. 일반 함수 호출 시 함수 내부의 this는 지정되지 않고 전역 객체를 값으로 갖습니다.

사실 함수가 호출되는 상황에 따라, 어떻게 바인딩을 해야 할 지를 정하는 규칙들이 존재합니다.

**this의 4가지 바인딩 규칙**

1. 기본 바인딩
    
    자바스크립트 함수를 호출하는 가장 기본적인 방법은 함수를 단독 실행하는 것입니다.
    
    함수를 단독 실행하게 되면 this는 기본적으로 전역 객체인 window에 바인딩 됩니다.
    
    이때 주의해야 할 점은 ‘use strict’를 통해 엄격 모드를 사용하게 되면 전역 객체가 바인딩의 대상에서 제외되므로 this는 undefined 값을 갖게 됩니다. 
    
2. 암시적 바인딩
    
    함수가 객체의 메소드로 호출될 때, this는 함수를 포함하고 있는 객체에 바인딩이 됩니다.
    
    이러한 방식을 암시적 바인딩이라고 합니다.
    
3. 명시적 바인딩
    
    함수 호출시 함수 내부의 this가 지정되지 않는 문제를 해결하기 위한 방법입니다.
    
    함수는 call, apply, bind 메소드를 갖고 있어 명시적으로 바인딩을 할 수 있습니다.
    
    call, apply 메소드는 함수를 즉시 호출하면서 this 값을 지정하며, call은 개별 인자를 전달하고, apply는 배열로 인자를 전달합니다.
    
    // apply : **myFunction.call(obj, arg1, arg2)**
    
    // call : **myFunction.apply(obj, [arg1, arg2])**
    
    bind 메소드는 함수를 호출하지 않고, this 값과 인자를 갖는 새로운 함수를 생성합니다. 이후 필요한 시점에 호출할 수 있습니다.
    
    // **const boundFunction = myFunction.bind(obj, arg1, arg2)**
    
4. new 바인딩
    
    new 키워드를 사용하여 생성자 함수를 호출할 수 있습니다.
    
    new 바인딩을 간략하게 설명드리자면, 
    
    1. 새 객체가 만들어짐
    2. 생성자 함수의 코드가 실행되면서, this는 새 객체에 바인딩됩니다.
    3. 새로 생성된 객체가 반환됨
    

함수가 위의 4가지의 방법 중 한 가지에만 해당하면 좋지만 만약 중복된다면 우선순위를 통해 결정합니다.

1. new 바인딩 2. 명시적 바인딩 3. 암시적 바인딩 4. 기본 바인딩의 순서로 우선순위가 결정됩니다.

마지막으로, 화살표 함수안에서는 this를 자체적으로 갖지 않습니다.

다만 화살표 함수 내부에서 this를 참조하면, 함수가 정의된 곳의 상위 스코프에서 this를 상속 받습니다.
*/