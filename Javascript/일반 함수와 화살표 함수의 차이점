/*
일반 함수는 함수 선언문으로 작성된 함수이고, 화살표 함수는 함수 표현식으로 작성된 함수입니다.

화살표 함수는 ES6에 도입된 문법으로, 일반 함수보다 간결하게 작성하는 장점이 있습니다.

일반 함수와 화살표 함수는 몇 가지 차이점을 갖습니다.

1. 문법
    
    일반 함수는 function 키워드를 사용하여 정의하며, 화살표 함수는 function 키워드를 생략하고, 화살표를 사용해 정의합니다.
    
2. arguments 바인딩
    
    일반 함수에서 arguments 객체를 사용할 수 있지만 화살표 함수에서는 사용할 수 없습니다.
    
    function test() {
    console.log("arguments",arguments);
    }
    console.log(test(1,2,3)); // {
    "0": 1,
    "1": 2,
    "2": 3
    }
    
3. this 키워드 사용
    
    일반 함수는,
    
    1. 함수 실행 시에는 전역 객체를 가르키고,
    2. 메소드 실행 시에는 메소드를 실행한 객체를 가르키고,
    3. 생성자 함수를 실행시에는 새롭게 만들어진 객체를 가르킵니다.
    
    화살표 함수는,
    
    상위 스코프의 this를 가르킵니다.
    

**화살표 함수를 사용하면서 주의해야할 상황**

1. 메소드로써 화살표 함수를 사용할 때
    
    화살표 함수는 this를 상위 스코프의 this를 상속받기 때문에 일반 함수와는 다르게 동작합니다.
    
2. 생성자 함수
    
    화살표 함수를 생성자 함수로 사용하면 에러가 발생합니다.
    
    ```
    const Foo = () => {};
    const foo = new Foo()	// TypeError: Foo is not a constructor
    ```
    
3. addEventListener()의 콜백 함수
    
    화살표 함수를 사용하면 기존 바인딩된 값이 사라지고, 상위 스코프의 this 값을 상속받기 때문에 주의해야합니다.
    */
